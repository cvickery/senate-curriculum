#! /usr/bin/env python3
"""
    Reads CUNYFirst course catalog and populates Postgres table gened.cf_catalog.
    The CF course catalog is an Excel spreadsheet generated by the QCCV_CU_CATALOG
    query.
"""

"""
TODO: duplicates have to go in. They may legitimately differ in offer_nbr and
component_course_component. Maybe more...

CONSTRAINT cf_catalog_pkey PRIMARY KEY (course_id, offer_nbr, component_course_component)
"""

import pprint

import sys
import inspect
import xlrd3
import psycopg2
import re

#   NamedTupleConnection lets psycopg2 get column names in queries
import collections
from psycopg2.extras import NamedTupleConnection

"""
    Functions for formatting Excel cells.
"""
def xl_text(cell):
    """ Replace all straight quotes with curly ones; replace newlines with spaces.
        Strips whitespace from ends.
    """
    returnValue = cell.value.replace("'", "’")
    returnValue = re.sub('([^ ]")', '\1“', returnValue)
    returnValue = returnValue.replace('"', '”')
    returnValue = returnValue.replace("\n", " ")
    return returnValue.strip()

def xl_number(cell):
    return '{}'.format(cell.value)

def xl_date(cell):
    try:
        date_tuple = xlrd3.xldate_as_tuple(cell.value, wbk.datemode)
        return '{:4d}-{:02d}-{:02d}'.format(date_tuple[0], date_tuple[1], date_tuple[2])
    except:
        return None

def xl_bool(cell):
    return None

def xl_empty(cell):
    return ''

def xl_error(cell):
    return '#error'

def xl_blank(cell):
    return ''

formats = { xlrd3.XL_CELL_EMPTY     :   xl_empty,
            xlrd3.XL_CELL_TEXT      :   xl_text,
            xlrd3.XL_CELL_NUMBER    :   xl_number,
            xlrd3.XL_CELL_DATE      :   xl_date,
            xlrd3.XL_CELL_BOOLEAN   :   xl_bool,
            xlrd3.XL_CELL_ERROR     :   xl_error,
            xlrd3.XL_CELL_BLANK     :   xl_blank
          }

#   Handle duplicate course_ids
def duplicate_id(row):
    """ Print associated information for duplicated course_ids. """
    dup_cur = db.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)
    course_id = row[0].value.lstrip('0')
    dup_cur.execute("SELECT * FROM cf_catalog WHERE course_id = " + course_id)
    db_row = dup_cur.fetchone()
    print("Duplicate course_id:", course_id)
    diffs = False
    for n in range(1, len(cols)):
        dup_value = "{}".format(formats[row[n].ctype](row[n]))
        if dup_value == '' or dup_value == 'None': dup_value = None
        db_value = "{}".format(db_row[n])
        if db_value == '' or db_value == 'None': db_value = None
        if dup_value != db_value:
            diffs = True
            print("    {:<28}: |{}| <=> |{}|".format(cols[n], dup_value, db_value ))
    if not diffs:
        print("    Records are the same")
    print()
    return

#   Open CF catalog query file
file = "QCCV_CU_CATALOG.xls"
if len(sys.argv) > 1:
    file = sys.argv[1]

wbk = xlrd3.open_workbook(file) or die('Unable to open:', file)

db = psycopg2.connect("host='localhost' dbname='gened' user='vickery'") or die('Unable to connect')
cur = db.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)

#   Extract disciplines, deans (divisions), and departments from gened db.
cur.execute("SELECT * FROM disciplines ORDER BY abbreviation")
disciplines = {row for row in cur}
discipline_abbreviations = [row.abbreviation for row in cur]
cur.execute("SELECT * FROM deans")
divisions = [row for row in cur]
cur.execute("SELECT * FROM departments")
departments = [row for row in cur]

#
#   Create/Replace cf_catalog
#   ---------------------------------------------------------------------------

#   Generate db column names from query column names
sht = wbk.sheet_by_index(0)
cells = sht.row(1)  # Heading row
space2underscore = str.maketrans(' ', '_')
cols = [cell.value.lower().translate(space2underscore) for cell in cells]

#   Drop existing table and create new one
cur.execute("DROP TABLE IF EXISTS cf_catalog")
query = """
CREATE TABLE cf_catalog (
    course_id                    integer"""

#   All fields after course_id are text unless column name ends in _date
for col in range(1, len(cols)):
    cell = cols[col]
    if cell.endswith("_date"):
        query += """,
    {:<28} date""".format(cell)
    else:
        query += """,
    {:<28} text""".format(cell)
query += """,
    CONSTRAINT cf_pkey PRIMARY KEY (course_id, offer_nbr, component_course_component))
"""
cur.execute(query)

#   Populate the table
course_ids = set()
for row in range(2,sht.nrows):
    #   Check course_id is a non-duplicated integer
    course_id                   = sht.row(row)[0].value
    if not course_id.isdigit():
        print("Non-integer course_id", course_id)
        continue
    if course_id in course_ids:
        duplicate_id(sht.row(row))
    course_ids.add(course_id)

    #   Generate query string
    query = "INSERT INTO cf_catalog VALUES ( " + course_id
   
    for n in range(1, len(cols)):
        cell = sht.row(row)[n]
        if cols[n].endswith("_date"):
            if cell.value == "":
                value = ", null"
            else:
                value = ", '{}'::date".format(formats[cell.ctype](cell))
        else:
            if cell.ctype == xlrd3.XL_CELL_TEXT and cell.value.endswith("\\"):
                #   Text can be anything, so long as it doesn't end with '\'
                print("Course_id {}: {} ends with '\\' (|{}|)".format(course_id, 
                        cols[n], cell.value))
                cell.value = cell.value.strip("\\")
            value = ", '{}'".format(formats[cell.ctype](cell))
        query += value
    query += ")"
    cur.execute(query)


# for row in range(2,sht.nrows):
#     course_id       = sht.row(row)[0]
#     effective_date  = sht.row(row)[1]
#     query = """
# INSERT INTO cf_catalog VALUES (
#     {},
#     '{}'::date""".format(formats[course_id.ctype](course_id),
#                          formats[effective_date.ctype](effective_date))
#     for x in range(2, len(cols)):
#         cell = sht.row(row)[x]
#         query += """,
#         '{}'""".format(formats[cell.ctype](cell))
#     query += ")"
#     cur.execute(query)

cur.close()
db.commit()
db.close()

